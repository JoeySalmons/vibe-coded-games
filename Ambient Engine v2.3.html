<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Ambient Engine</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            background-color: #000;
            font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', sans-serif;
            -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
            touch-action: none;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            cursor: none;
        }
        .controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
            z-index: 10;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .controls button, .controls select {
            background-color: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s;
            font-family: inherit;
            font-size: 14px;
        }
        .controls button:hover, .controls select:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }
        .controls button:active {
            transform: scale(0.95);
        }
        .controls select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            padding-right: 30px;
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%27http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%27%20width%3D%27292.4%27%20height%3D%27292.4%27%3E%3Cpath%20fill%3D%27%23FFFFFF%27%20d%3D%27M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%27%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat;
            background-position: right 10px top 50%;
            background-size: .65em auto;
        }
    </style>
</head>
<body>
    <canvas id="ambientCanvas"></canvas>
    <div class="controls">
        <select id="effectSelector"></select>
        <button id="resetBtn">Reset Particles</button>
        <button id="trailsBtn">Trails: On</button>
    </div>

    <script>
        const canvas = document.getElementById('ambientCanvas');
        const ctx = canvas.getContext('2d');

        let width, height;
        let particles = [];
        let hue = 0;
        let interactionPoints = [];
        let useTrails = true;
        let frameCount = 0;

        const PARTICLE_COUNT = 350;
        const INTERACTION_RADIUS = 200;

        const EFFECTS = {
            REPEL:          { name: 'Repel', friction: 0.96 },
            ATTRACT:        { name: 'Attract', friction: 0.94 },
            VORTEX:         { name: 'Vortex', friction: 0.97 },
            RINGS_AND_WAVES:{ name: 'Rings & Waves', friction: 0.98 },
            GRID_DEFORM:    { name: 'Grid Deform', friction: 0.92 },
            INFINITY:       { name: 'Infinity', friction: 0.97 },
            COSMIC_RIVER:   { name: 'Cosmic River', friction: 0.99 },
            ETERNAL_ORBIT:  { name: 'Eternal Orbit', friction: 0.995 },
            CHAOTIC_SWARM:  { name: 'Chaotic Swarm', friction: 0.97 },
        };
        let currentInteractionMode = 'REPEL';

        // --- CLASSES ---
        class Particle {
            constructor() {
                this.reset();
                this.radius = Math.random() * 1.5 + 1;
                this.baseColor = `hsl(${Math.random() * 60 + 200}, 100%, 70%)`;
            }

            reset() {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.vx = 0;
                this.vy = 0;
            }

            applyForce(fx, fy) {
                this.vx += fx;
                this.vy += fy;
            }

            update() {
                const effect = EFFECTS[currentInteractionMode];

                // --- BASE FORCES (Independent of user interaction) ---
                if (currentInteractionMode === 'COSMIC_RIVER') {
                    const riverStrength = 0.0015; // Tuned down
                    const targetX = width * 0.5 + Math.sin(this.y / 100 + frameCount * 0.01) * width * 0.3;
                    this.vx += (targetX - this.x) * riverStrength;
                } else if (currentInteractionMode === 'CHAOTIC_SWARM') {
                    if (Math.sqrt(this.vx * this.vx + this.vy * this.vy) < 0.5) {
                        this.vx += (Math.random() - 0.5) * 0.1;
                        this.vy += (Math.random() - 0.5) * 0.1;
                    }
                } else if (currentInteractionMode === 'RINGS_AND_WAVES') {
                    // Rings from center
                    const dxCenter = this.x - width / 2;
                    const dyCenter = this.y - height / 2;
                    const distFromCenter = Math.sqrt(dxCenter * dxCenter + dyCenter * dyCenter);
                    const angleFromCenter = Math.atan2(dyCenter, dxCenter);
                    const ringForce = Math.sin(distFromCenter / 50) * 0.005;
                    this.vx += Math.cos(angleFromCenter) * ringForce;
                    this.vy += Math.sin(angleFromCenter) * ringForce;

                    // Wave distortion
                    const waveForceX = Math.sin(this.y / 70 + frameCount * 0.02) * 0.01;
                    const waveForceY = Math.cos(this.x / 80 + frameCount * 0.015) * 0.01;
                    this.vx += waveForceX;
                    this.vy += waveForceY;
                }

                // --- INTERACTIVE FORCES ---
                interactionPoints.forEach(point => {
                    this.calculateForces(point);
                });

                this.vx *= effect.friction;
                this.vy *= effect.friction;
                this.x += this.vx;
                this.y += this.vy;

                // --- EDGE WRAPPING ---
                if (this.x > width + this.radius) this.x = -this.radius; if (this.x < -this.radius) this.x = width + this.radius;
                if (this.y > height + this.radius) this.y = -this.radius; if (this.y < -this.radius) this.y = height + this.radius;
            }

            calculateForces(point) {
                const dx = this.x - point.x;
                const dy = this.y - point.y;
                let distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < 1) distance = 1;
                const angle = Math.atan2(dy, dx);
                let forceMagnitude = 0;

                if (distance < INTERACTION_RADIUS) {
                    const influence = 1 - distance / INTERACTION_RADIUS;
                    
                    switch (currentInteractionMode) {
                        case 'REPEL':
                        case 'CHAOTIC_SWARM':
                        case 'RINGS_AND_WAVES': // Interaction for this is repulsion
                            forceMagnitude = influence * 0.8;
                            this.applyForce(Math.cos(angle) * forceMagnitude, Math.sin(angle) * forceMagnitude);
                            break;
                        case 'COSMIC_RIVER':
                            forceMagnitude = influence * 0.4; // Tuned down
                            this.applyForce(Math.cos(angle) * forceMagnitude, Math.sin(angle) * forceMagnitude);
                            break;
                        case 'ATTRACT':
                            forceMagnitude = influence * 0.6;
                            this.applyForce(-Math.cos(angle) * forceMagnitude, -Math.sin(angle) * forceMagnitude);
                            break;
                        case 'VORTEX':
                            this.applyForce(-Math.cos(angle) * influence * 0.3, -Math.sin(angle) * influence * 0.3);
                            this.applyForce(Math.cos(angle - Math.PI / 2) * influence * 0.6, Math.sin(angle - Math.PI / 2) * influence * 0.6);
                            break;
                        case 'GRID_DEFORM':
                            const targetY = this.y + Math.sin(this.x * 0.03) * 10 * influence;
                            const targetX = this.x + Math.cos(this.y * 0.03) * 10 * influence;
                            this.applyForce((targetX - this.x) * 0.01, (targetY - this.y) * 0.01);
                            break;
                        case 'INFINITY':
                            const sizeMultiplier = 0.75 + (Math.sin(frameCount * 0.01) + 1) * 0.25; // Oscillates between 0.75 and 1.25
                            this.applyForce(-dx * 0.002, -dy * 0.002);
                            const swirlForce = Math.sin(angle * 2) * 0.5 * influence * sizeMultiplier;
                            this.applyForce(Math.cos(angle - Math.PI / 2) * swirlForce, Math.sin(angle - Math.PI / 2) * swirlForce);
                            break;
                        case 'ETERNAL_ORBIT':
                             this.applyForce(dx / distance * -0.01 * influence, dy / distance * -0.01 * influence);
                             this.applyForce(-dy / distance * 0.04 * influence, dx / distance * 0.04 * influence);
                             break;
                    }
                }
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.baseColor;
                ctx.fill();
            }
        }

        // --- INITIALIZATION & UI SETUP ---
        function setup() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            populateEffectSelector();
            initParticles();
        }

        function initParticles() {
            if (particles.length === 0) {
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    particles.push(new Particle());
                }
            } else {
                particles.forEach(p => p.reset());
            }
        }

        function populateEffectSelector() {
            const selector = document.getElementById('effectSelector');
            selector.innerHTML = '';
            for (const key in EFFECTS) {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = EFFECTS[key].name;
                selector.appendChild(option);
            }
            selector.value = currentInteractionMode;
        }

        // --- ANIMATION LOOP ---
        function animate() {
            if (useTrails) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                ctx.fillRect(0, 0, width, height);
            } else {
                ctx.clearRect(0, 0, width, height);
            }
            const gradient = ctx.createRadialGradient(width / 2, height / 2, 0, width / 2, height / 2, Math.max(width, height));
            gradient.addColorStop(0, `hsl(${hue}, 80%, 20%)`);
            gradient.addColorStop(1, `hsl(${hue + 60}, 80%, 5%)`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);

            particles.forEach(p => { p.update(); p.draw(); });
            
            interactionPoints.forEach(point => {
                const cursorGradient = ctx.createRadialGradient(point.x, point.y, 0, point.x, point.y, 30);
                cursorGradient.addColorStop(0, `hsla(${hue + 180}, 100%, 70%, 0.5)`);
                cursorGradient.addColorStop(1, `hsla(${hue + 180}, 100%, 70%, 0)`);
                ctx.fillStyle = cursorGradient;
                ctx.fillRect(point.x - 30, point.y - 30, 60, 60);
            });
            
            hue = (hue + 0.1) % 360;
            frameCount++;
            requestAnimationFrame(animate);
        }

        // --- EVENT HANDLERS ---
        function handleInteraction(e) {
            if (e.target !== canvas) return;
            e.preventDefault();
            interactionPoints = [];
            if (e.touches) {
                for (let i = 0; i < e.touches.length; i++) {
                    interactionPoints.push({ x: e.touches[i].clientX, y: e.touches[i].clientY });
                }
            } else if (e.buttons === 1) {
                interactionPoints.push({ x: e.clientX, y: e.clientY });
            }
        }
        
        function clearInteraction() { interactionPoints = []; }

        // --- EVENT LISTENERS ---
        document.getElementById('effectSelector').addEventListener('change', (e) => {
            currentInteractionMode = e.target.value;
            // Particles are NOT reset here anymore
        });
        
        document.getElementById('resetBtn').addEventListener('click', initParticles);
        
        document.getElementById('trailsBtn').addEventListener('click', (e) => {
            useTrails = !useTrails;
            e.target.textContent = `Trails: ${useTrails ? 'On' : 'Off'}`;
        });

        window.addEventListener('resize', setup);
        window.addEventListener('mousedown', handleInteraction);
        window.addEventListener('mousemove', handleInteraction);
        window.addEventListener('mouseup', clearInteraction);
        window.addEventListener('touchstart', handleInteraction, { passive: false });
        window.addEventListener('touchmove', handleInteraction, { passive: false });
        window.addEventListener('touchend', handleInteraction, { passive: false });
        window.addEventListener('touchcancel', clearInteraction);

        // --- START ---
        setup();
        animate();
    </script>
</body>
</html>